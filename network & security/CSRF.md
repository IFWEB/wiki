## CSRF攻击原理
CSRF：Cross Site Request Forgery, 跨站域请求伪造  

简单一句话：用户登录A网站后浏览器保存用户登录态cookie。此时在浏览器打开B网站，B网站调用A网站的接口也是具有登录态的。如果这个接口是一个读写敏感信息的接口，那么CSRF攻击成立。

## CSRF攻击方式
简单举例  
GET的方式：编写了一个伪造的银行站点上进行取款的form提交的链接，并将此链接作为图片src（攻击者把图片连接发给你，诱惑你去点击）  

POST方式：利用xss注入脚本代码；或是从第三方网站发动攻击（多窗口浏览器提供了帮组，多窗口浏览器新开的窗口是具有当前所有会话的，a页签先打开，b页签后打开，在b页签模拟a页签中的某些请求【当然也可以模拟get请求】），form表单跨域可以做跨域提交，只不过无法得到返回值。ajax模式需要浏览器和服务器支持CORS跨域才能提交；  

## CSRF防御方式
**1、用户操作限制方法**：比如验证码等，这个不太适合所有的请求。  


**2、瞬时的授权方法**：将持久化的授权方法（例如cookie或者HTTP授权）切换为瞬时的授权方法（在每个form中提供隐藏field），这将帮助网站防止这些攻击。一种类似的方式是在form中包含秘密信息、用户指定的代号作为cookie之外的验证。  
**这种方法局限比较大，比较适合服务端渲染的方式，而且对ajax不友好**  
  
**3、“双提交”cookie**：此方法只工作于Ajax请求，读取指定代号的cookie并将cookie作为请求体的一部分传递给后台，后台检测指定代号的cookie并检测请求体中是否同时存在该cookie。第三方完整无法获取到指定代号的cookie写入请求体，由于它域是不能从信任域读取cookie的。  
**这种方法适合前后端分离的情况使用，但是要保证接口请求都使用ajax，需要对所有ajax请求前塞入这个cookie的处理**   
**这个验证用的cookie过期时间和登录态的cookie的过期时间保持同步即可，用户登录过期，则该cookie失效，而且这个cookie的生成是不容易被破解的**  
**这个方法有个缺点是验证用的cookie在get请求的时候会被浏览器历史记录，比如"https://www.aaa.com/getInfo?token=xxx"，再浏览器历史里面就能看到这个token为**"xxx"     
**需要注意特别是在一些论坛之类支持用户自己发表内容的网站，黑客可以在上面发布自己个人网站的地址。由于系统也会在这个地址后面加上token，黑客可以在自己的网站上得到这个 token，并马上就可以发动 CSRF 攻击。为了避免这一点，系统可以在添加 token 的时候增加一个判断，如果这个链接是链到自己本站的，就在后面添加token，如果是通向外网则不加。** 

  
**4、在HTTP头中自定义属性并验证**：这种方式实际上是“双提交”cookie的变种，与之不同的是，这里并不是把token以参数的形式置于HTTP请求之中，而是把它放到HTTP头中自定义的属性里。xhr.setRequestHeader("csrftoken", "xxxx")。通过这个类请求的地址不会被记录到浏览器的地址栏，也不用担心token会通过Referer泄露到其他网站。  
**这种方式是前后端分离情况下最好的方案**   

  
**5、验证http Referer字段**：根据HTTP协议，在HTTP头中有一个字段叫Referer，它记录了该HTTP请求的来源地址。不是在当前A域名网页中打开的(用window.open或href标签)新tab的请求的referer就不会是A域名。嵌入到B页面中的请求带上的referer都是B页面的域名。服务端可以设置Referer白名单，非白名单内的referer请求直接拒绝。  
**referer实现比较简单，无论是服务端渲染还是前后端分离都可以。问题如果浏览器有漏洞，可以篡改referer,是即便是使用最新的浏览器，黑客无法篡改 Referer 值;某些前端用户会禁用referer导致服务器判断错误**      
**可以选择不支持低版本浏览器，这样对内使用的系统用referer也是一个不错的选择**  
**referer实际上大量使用场景是防止图片盗链。其他网站引用我站图片时拒绝返回**  


JWT方案

**其他说明**：1、2方法需要服务端有保存相应的SESSION能力（知道是哪个用户对应的token）；3、4方法可以在node做接口层并且没有SESSION、数据库能力的情况下使用。综合来说 **4才是公认最安全的方式**。




  